/*
 * Crypt.cpp
 *
 *  Created on: 27.07.2015
 *      Author: nikolay shalakin
 *
 *  GOST 28147-89 gamming-crypt algorithm implementation
 *
 */

#include "Crypt.h"
#include <fstream>
#include <cstring>

#include <iostream>
#include <iomanip>
#include <string>

namespace GOST
{
static const uint defaultSBox[4][256] =
{
    {0x6c,0x64,0x66,0x62,0x6a,0x65,0x6b,0x69,0x6e,0x68,0x6d,0x67,0x60,0x63,0x6f,0x61,0x8c,0x84,0x86,0x82,0x8a,0x85,0x8b,0x89,0x8e,0x88,0x8d,0x87,0x80,0x83,0x8f,0x81,0x2c,0x24,0x26,0x22,0x2a,0x25,0x2b,0x29,0x2e,0x28,0x2d,0x27,0x20,0x23,0x2f,0x21,0x3c,0x34,0x36,0x32,0x3a,0x35,0x3b,0x39,0x3e,0x38,0x3d,0x37,0x30,0x33,0x3f,0x31,0x9c,0x94,0x96,0x92,0x9a,0x95,0x9b,0x99,0x9e,0x98,0x9d,0x97,0x90,0x93,0x9f,0x91,0xac,0xa4,0xa6,0xa2,0xaa,0xa5,0xab,0xa9,0xae,0xa8,0xad,0xa7,0xa0,0xa3,0xaf,0xa1,0x5c,0x54,0x56,0x52,0x5a,0x55,0x5b,0x59,0x5e,0x58,0x5d,0x57,0x50,0x53,0x5f,0x51,0xcc,0xc4,0xc6,0xc2,0xca,0xc5,0xcb,0xc9,0xce,0xc8,0xcd,0xc7,0xc0,0xc3,0xcf,0xc1,0x1c,0x14,0x16,0x12,0x1a,0x15,0x1b,0x19,0x1e,0x18,0x1d,0x17,0x10,0x13,0x1f,0x11,0xec,0xe4,0xe6,0xe2,0xea,0xe5,0xeb,0xe9,0xee,0xe8,0xed,0xe7,0xe0,0xe3,0xef,0xe1,0x4c,0x44,0x46,0x42,0x4a,0x45,0x4b,0x49,0x4e,0x48,0x4d,0x47,0x40,0x43,0x4f,0x41,0x7c,0x74,0x76,0x72,0x7a,0x75,0x7b,0x79,0x7e,0x78,0x7d,0x77,0x70,0x73,0x7f,0x71,0xbc,0xb4,0xb6,0xb2,0xba,0xb5,0xbb,0xb9,0xbe,0xb8,0xbd,0xb7,0xb0,0xb3,0xbf,0xb1,0xdc,0xd4,0xd6,0xd2,0xda,0xd5,0xdb,0xd9,0xde,0xd8,0xdd,0xd7,0xd0,0xd3,0xdf,0xd1,0xc,0x4,0x6,0x2,0xa,0x5,0xb,0x9,0xe,0x8,0xd,0x7,0x0,0x3,0xf,0x1,0xfc,0xf4,0xf6,0xf2,0xfa,0xf5,0xfb,0xf9,0xfe,0xf8,0xfd,0xf7,0xf0,0xf3,0xff,0xf1,},
    {0xcb,0xc3,0xc5,0xc8,0xc2,0xcf,0xca,0xcd,0xce,0xc1,0xc7,0xc4,0xcc,0xc9,0xc6,0xc0,0x8b,0x83,0x85,0x88,0x82,0x8f,0x8a,0x8d,0x8e,0x81,0x87,0x84,0x8c,0x89,0x86,0x80,0x2b,0x23,0x25,0x28,0x22,0x2f,0x2a,0x2d,0x2e,0x21,0x27,0x24,0x2c,0x29,0x26,0x20,0x1b,0x13,0x15,0x18,0x12,0x1f,0x1a,0x1d,0x1e,0x11,0x17,0x14,0x1c,0x19,0x16,0x10,0xdb,0xd3,0xd5,0xd8,0xd2,0xdf,0xda,0xdd,0xde,0xd1,0xd7,0xd4,0xdc,0xd9,0xd6,0xd0,0x4b,0x43,0x45,0x48,0x42,0x4f,0x4a,0x4d,0x4e,0x41,0x47,0x44,0x4c,0x49,0x46,0x40,0xfb,0xf3,0xf5,0xf8,0xf2,0xff,0xfa,0xfd,0xfe,0xf1,0xf7,0xf4,0xfc,0xf9,0xf6,0xf0,0x6b,0x63,0x65,0x68,0x62,0x6f,0x6a,0x6d,0x6e,0x61,0x67,0x64,0x6c,0x69,0x66,0x60,0x7b,0x73,0x75,0x78,0x72,0x7f,0x7a,0x7d,0x7e,0x71,0x77,0x74,0x7c,0x79,0x76,0x70,0xb,0x3,0x5,0x8,0x2,0xf,0xa,0xd,0xe,0x1,0x7,0x4,0xc,0x9,0x6,0x0,0xab,0xa3,0xa5,0xa8,0xa2,0xaf,0xaa,0xad,0xae,0xa1,0xa7,0xa4,0xac,0xa9,0xa6,0xa0,0x5b,0x53,0x55,0x58,0x52,0x5f,0x5a,0x5d,0x5e,0x51,0x57,0x54,0x5c,0x59,0x56,0x50,0x3b,0x33,0x35,0x38,0x32,0x3f,0x3a,0x3d,0x3e,0x31,0x37,0x34,0x3c,0x39,0x36,0x30,0xeb,0xe3,0xe5,0xe8,0xe2,0xef,0xea,0xed,0xee,0xe1,0xe7,0xe4,0xec,0xe9,0xe6,0xe0,0x9b,0x93,0x95,0x98,0x92,0x9f,0x9a,0x9d,0x9e,0x91,0x97,0x94,0x9c,0x99,0x96,0x90,0xbb,0xb3,0xb5,0xb8,0xb2,0xbf,0xba,0xbd,0xbe,0xb1,0xb7,0xb4,0xbc,0xb9,0xb6,0xb0,},
    {0x57,0x5f,0x55,0x5a,0x58,0x51,0x56,0x5d,0x50,0x59,0x53,0x5e,0x5b,0x54,0x52,0x5c,0xd7,0xdf,0xd5,0xda,0xd8,0xd1,0xd6,0xdd,0xd0,0xd9,0xd3,0xde,0xdb,0xd4,0xd2,0xdc,0xf7,0xff,0xf5,0xfa,0xf8,0xf1,0xf6,0xfd,0xf0,0xf9,0xf3,0xfe,0xfb,0xf4,0xf2,0xfc,0x67,0x6f,0x65,0x6a,0x68,0x61,0x66,0x6d,0x60,0x69,0x63,0x6e,0x6b,0x64,0x62,0x6c,0x97,0x9f,0x95,0x9a,0x98,0x91,0x96,0x9d,0x90,0x99,0x93,0x9e,0x9b,0x94,0x92,0x9c,0x27,0x2f,0x25,0x2a,0x28,0x21,0x26,0x2d,0x20,0x29,0x23,0x2e,0x2b,0x24,0x22,0x2c,0xc7,0xcf,0xc5,0xca,0xc8,0xc1,0xc6,0xcd,0xc0,0xc9,0xc3,0xce,0xcb,0xc4,0xc2,0xcc,0xa7,0xaf,0xa5,0xaa,0xa8,0xa1,0xa6,0xad,0xa0,0xa9,0xa3,0xae,0xab,0xa4,0xa2,0xac,0xb7,0xbf,0xb5,0xba,0xb8,0xb1,0xb6,0xbd,0xb0,0xb9,0xb3,0xbe,0xbb,0xb4,0xb2,0xbc,0x77,0x7f,0x75,0x7a,0x78,0x71,0x76,0x7d,0x70,0x79,0x73,0x7e,0x7b,0x74,0x72,0x7c,0x87,0x8f,0x85,0x8a,0x88,0x81,0x86,0x8d,0x80,0x89,0x83,0x8e,0x8b,0x84,0x82,0x8c,0x17,0x1f,0x15,0x1a,0x18,0x11,0x16,0x1d,0x10,0x19,0x13,0x1e,0x1b,0x14,0x12,0x1c,0x47,0x4f,0x45,0x4a,0x48,0x41,0x46,0x4d,0x40,0x49,0x43,0x4e,0x4b,0x44,0x42,0x4c,0x37,0x3f,0x35,0x3a,0x38,0x31,0x36,0x3d,0x30,0x39,0x33,0x3e,0x3b,0x34,0x32,0x3c,0xe7,0xef,0xe5,0xea,0xe8,0xe1,0xe6,0xed,0xe0,0xe9,0xe3,0xee,0xeb,0xe4,0xe2,0xec,0x7,0xf,0x5,0xa,0x8,0x1,0x6,0xd,0x0,0x9,0x3,0xe,0xb,0x4,0x2,0xc,},
    {0x18,0x1e,0x12,0x15,0x16,0x19,0x11,0x1c,0x1f,0x14,0x1b,0x10,0x1d,0x1a,0x13,0x17,0x78,0x7e,0x72,0x75,0x76,0x79,0x71,0x7c,0x7f,0x74,0x7b,0x70,0x7d,0x7a,0x73,0x77,0xe8,0xee,0xe2,0xe5,0xe6,0xe9,0xe1,0xec,0xef,0xe4,0xeb,0xe0,0xed,0xea,0xe3,0xe7,0xd8,0xde,0xd2,0xd5,0xd6,0xd9,0xd1,0xdc,0xdf,0xd4,0xdb,0xd0,0xdd,0xda,0xd3,0xd7,0x8,0xe,0x2,0x5,0x6,0x9,0x1,0xc,0xf,0x4,0xb,0x0,0xd,0xa,0x3,0x7,0x58,0x5e,0x52,0x55,0x56,0x59,0x51,0x5c,0x5f,0x54,0x5b,0x50,0x5d,0x5a,0x53,0x57,0x88,0x8e,0x82,0x85,0x86,0x89,0x81,0x8c,0x8f,0x84,0x8b,0x80,0x8d,0x8a,0x83,0x87,0x38,0x3e,0x32,0x35,0x36,0x39,0x31,0x3c,0x3f,0x34,0x3b,0x30,0x3d,0x3a,0x33,0x37,0x48,0x4e,0x42,0x45,0x46,0x49,0x41,0x4c,0x4f,0x44,0x4b,0x40,0x4d,0x4a,0x43,0x47,0xf8,0xfe,0xf2,0xf5,0xf6,0xf9,0xf1,0xfc,0xff,0xf4,0xfb,0xf0,0xfd,0xfa,0xf3,0xf7,0xa8,0xae,0xa2,0xa5,0xa6,0xa9,0xa1,0xac,0xaf,0xa4,0xab,0xa0,0xad,0xaa,0xa3,0xa7,0x68,0x6e,0x62,0x65,0x66,0x69,0x61,0x6c,0x6f,0x64,0x6b,0x60,0x6d,0x6a,0x63,0x67,0x98,0x9e,0x92,0x95,0x96,0x99,0x91,0x9c,0x9f,0x94,0x9b,0x90,0x9d,0x9a,0x93,0x97,0xc8,0xce,0xc2,0xc5,0xc6,0xc9,0xc1,0xcc,0xcf,0xc4,0xcb,0xc0,0xcd,0xca,0xc3,0xc7,0xb8,0xbe,0xb2,0xb5,0xb6,0xb9,0xb1,0xbc,0xbf,0xb4,0xbb,0xb0,0xbd,0xba,0xb3,0xb7,0x28,0x2e,0x22,0x25,0x26,0x29,0x21,0x2c,0x2f,0x24,0x2b,0x20,0x2d,0x2a,0x23,0x27,},
};

static const uint cryptRounds[32] =
{
    0,1,2,3,4,5,6,7,
    0,1,2,3,4,5,6,7,
    0,1,2,3,4,5,6,7,
    7,6,5,4,3,2,1,0
};

static const uint C1 = 0x1010104;
static const uint C2 = 0x1010101;

static uint X[8];			// splitted key

inline static void bytesToU32(uint& dst, const byte* scr)
{
    dst |= scr[0];
    dst |= scr[1] << 8;
    dst |= scr[2] << 16;
    dst |= scr[3] << 24;
}

inline static void u32ToBytes(char* dst, const uint scr)
{
    dst[0] = scr;
    dst[1] = scr >> 8;
    dst[2] = scr >> 16;
    dst[3] = scr >> 24;
}

inline static void splitKey(const byte* password)
{
    bytesToU32(X[0], password);
    bytesToU32(X[1], password+4);
    bytesToU32(X[2], password+8);
    bytesToU32(X[3], password+12);
    bytesToU32(X[4], password+16);
    bytesToU32(X[5], password+20);
    bytesToU32(X[6], password+24);
    bytesToU32(X[7], password+28);
}

// INTERFACE FUNCTIONS
Crypter::Crypter()
{
    useDefaultTable();
    useDefaultSync();
}

void Crypter::useDefaultTable()
{
    memcpy(SBox, defaultSBox, 4*256);
}

// file with 128 bytes representing SBox table for GOST encryption
void Crypter::setTable(const char* filename)
{
    using namespace std;

    fstream f;
    f.open(filename, fstream::in | fstream::binary);

    byte table[128];
    f.read((char*)table, 128);
    f.close();

    setTable(table);
}

/*
// 128 bytes representing SBox table for GOST encryption
// this 128 bytes will be transformed to special 4*256 table (for better algorythm performance)
void Crypter::setTable(const byte* table)
{
    byte* cursor = &SBox[0][0];

    for(uint i = 0; i<4; ++i) {
        for(uint j = 0; j<16; ++j) {
            for(uint k = 0; k<16; ++k) {
                *cursor = (table[i*2*16 + k]<<0) + ((table[i*2*16 + 16 + j])<<4);
                ++cursor;
            }
        }
    }
}
*/

void printSBox(u32 sbox_x[4][256])
{
	for (int i = 0; i < 4 * 256; ++i) {
		if (i % 8 == 0) {
			printf("\n");
		}
		printf("%08x ", ((u32*)sbox_x)[i]);
	}
	printf("\n\n");
}

void printRawSBox(u8 sbox_x[8][16])
{
	for (int i = 0; i < 8 * 16; ++i) {
		if (i % 8 == 0) {
			printf("\n");
		}
		printf("%02x ", ((u8*)sbox_x)[i]);
	}
	printf("\n\n");
}

// 128 bytes representing SBox table for GOST encryption
// this 128 bytes will be transformed to special 4*256 table (for better algorythm performance)
void Crypter::setTable(const byte* table)
{
	u8(*raw_sbox)[16] = (u8(*)[16])table;
	//printRawSBox(raw_sbox);

	u8 i;
	u8 j;
	u16 k;

	for (i = 0, j = 0; i < 4; i++, j += 2) {
		for (k = 0; k < 256; k++) {
			SBox[i][k] = (raw_sbox[j][k & 0x0f] | raw_sbox[j + 1][k >> 4] << 4) << (j * 4);
			SBox[i][k] = SBox[i][k] << 11 | SBox[i][k] >> (32 - 11);
		}
	}

	//printSBox(SBox);
}

void Crypter::useDefaultSync()
{
    Sync[0] = 0x40FD452C;
    Sync[1] = 0xF86EDCDB;
}

void Crypter::setSync(const u64 sync)
{
    Sync[0] = (uint)sync;
    Sync[1] = (uint)(sync>>32);
}

void Crypter::cryptString(byte* dst, const char* scr, const byte* password)
{
    cryptData(dst, (byte*)scr, strlen(scr), password);
}

void Crypter::decryptString(char* dst, const byte* scr, uint size, const byte* password)
{
    cryptData((byte*)dst, (byte*)scr, size, password);
    dst[size] = '\0';
}

inline static void print(const std::string &note) {
	using namespace std;
	cout << endl << note << endl;
}

inline static void _print32(const std::string &label, u32 val) {
	using namespace std;
	cout << label << ": " << hex << setw(8) << setfill('0') << val << endl;
}
#define print32(X) _print32(#X, X)

// INTERNAL FUNCTIONS
void Crypter::cryptData(byte* dst, const byte* scr, const uint size, const byte* password)
{
    if(size == 0) {
        return;
    }

	//print(std::to_string(size));

    register uint N1 = Sync[0];
    register uint N2 = Sync[1];

	
	/*print("Sync:");
	print32(N1);
	print32(N2);*/
	

    splitKey(password);

    simpleGOST(N1, N2);

	
	/*print("Crypted Sync:");
	print32(N1);
	print32(N2);*/
	

    uint remain = size%8;
    const byte* scrEnd = scr + size;

    register union
    {
        uint val;
        byte blob[4];
    } A, B;

    register uint G1, G2;

    while(true)
    {
        A.val = N2 + C1;    // use A while it is unused for its main purpose
        if(A.val <= N2)	// mod 2^32-1
            ++A.val;

        G1 = N1 = N1 + C2;
        G2 = N2 = A.val;

		/*
		print("Plain Gamma:");
		print32(G1);
		print32(G2);
		*/

        simpleGOST(G1, G2);

		/*
		print("Gamma:");
		print32(G1);
		print32(G2);
		*/

        memcpy(A.blob, scr, 4);
        scr += 4;

        memcpy(B.blob, scr, 4);
        scr += 4;

		/*
		print("Text:");
		print32(A.val);
		print32(B.val);
		*/

        A.val ^= G1;   // gamming
        B.val ^= G2;

		/*
		print("Crypted Text:");
		print32(A.val);
		print32(B.val);
		*/

        if(scr <= scrEnd)			// file doesn't end
        {
            memcpy(dst, A.blob, 4);
            dst += 4;

            memcpy(dst, B.blob, 4);
            dst += 4;

			if (scr == scrEnd) {
				break;
			}
        }
        else
        {
            uint remainA, remainB;

            if(remain <= 4)
            {
                remainA = remain;
                remainB = 0;
            }
            else
            {
                remainA = 4;
                remainB = remain - 4;
            }

            memcpy(dst, A.blob, remainA);
            dst += remainA;

            memcpy(dst, B.blob, remainB);
            dst += remainB;

            break;
        }
    }

    memset(X, 0, sizeof(X));
}


u32 f(u32 word, u32 sBox[4][256])
{
	return sBox[3][word >> 24] ^
		   sBox[2][(word & 0x00ff0000) >> 16] ^
		   sBox[1][(word & 0x0000ff00) >> 8] ^
		   sBox[0][(word & 0x000000ff)];
}

void swap32(u32 &a, u32 &b)
{
	u32 tmp = a;

	a = b;
	b = tmp;
}

void Crypter::simpleGOST(uint &A, uint &B)
{
	u8 i;

	for (i = 0; i < 31; i += 2) {
		B ^= f(A + X[cryptRounds[i]], SBox);
		A ^= f(B + X[cryptRounds[i+1]], SBox);
	}

	swap32(B, A);
}

/*
void Crypter::simpleGOST(uint& A, uint& B)
{
    union
    {
        uint val;
        byte blob[4];
    } T;

    for(uint i = 0; i<32; ++i)
    {
        T.val = A + X[cryptRounds[i]];

        T.val =
            SBox[0][T.blob[0]]     |
            SBox[1][T.blob[1]]<< 8 |
            SBox[2][T.blob[2]]<<16 |
            SBox[3][T.blob[3]]<<24;

        T.val = (T.val<<11)|(T.val>>21);
        T.val = T.val^B;

        if(i != 31)
        {
            B = A;
            A = T.val;
        }
        else
            B = T.val;
    }
}
*/

}

